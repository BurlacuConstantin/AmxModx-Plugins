/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <hamsandwich>
#include <fakemeta>
#include <fun>
#include <cstrike>
#include <fakemeta_util>
#include <left4dead>

#pragma tabsize 0

#define PLUGIN "Weapon Table"
#define VERSION "0.2"
#define AUTHOR "AsuStar"

native pipe_give_to_user(id)

new const random_weapons[] [] =
{
	"weapon_ak47",
	"weapon_m4a1",
	"weapon_aug",
	"weapon_awp",
	"weapon_famas",
	"weapon_galil",
	"weapon_g3sg1",
	"weapon_m3",
	"weapon_mac10",
	"weapon_mp5navy",
	"weapon_xm1014"
}

new const Tag[] = "!v[Weapon Table]!g:"

new AntiSpam[33],bool:AntiSpam2[33]

#define CLASS_NAME_TABLE "weapon_table_npc"

new const table_model[] = "models/player/table_l4d/table_l4d.mdl"

public plugin_init() 
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	register_touch(CLASS_NAME_TABLE,"player","Touch_Table")
	RegisterHam(Ham_Spawn,"player","Respawn",1)
	
	register_concmd("weapon_table","cmd_table")
}

public plugin_precache()
{
	precache_model(table_model)
}

public plugin_natives()
{
	register_native("l4d_weapon_table","native_l4d_weapon_table",1)
}

public l4d_weapon_table(id)
{
	cmd_table(id)
}

public plugin_cfg()
{
	Load_Table()
}

public client_putinserver(id)
{
	AntiSpam2[id] = false
}

public client_disconnect(id)
{
	AntiSpam2[id] = false
}

public l4d_end_round(id)
{
	AntiSpam2[id] = false
}

public l4d_start_new_round(id)
{
	AntiSpam2[id] = false
}

public Respawn(id)
{
	AntiSpam2[id] = false
}

public cmd_table(id)
{
	if((get_user_flags(id) & ADMIN_IMMUNITY))
	{
		new menu = menu_create("Weapon Table", "Menu_Handler2")
		
		menu_additem(menu, "Creaza", "1")
		menu_additem(menu, "Sterge", "2")
		menu_additem(menu, "Salveaza locatia", "3")
		menu_additem(menu, "Sterge toate", "4")
		
		menu_setprop(menu, MPROP_EXIT, MEXIT_ALL)
		
		menu_display(id, menu)
	}
	else
	{
		client_print(id,print_console,"%s Nu ai acces la aceasta comanda!",Tag)
		ColorChat(id,"%s Nu ai acces la aceasta comanda!",Tag)
		return PLUGIN_HANDLED
	}
	return PLUGIN_CONTINUE
}

public Menu_Handler2(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED
	}
	
	new info[6], szName[64]
	new access, callback
	
	menu_item_getinfo(menu, item, access, info, charsmax(info), szName, charsmax(szName), callback);
	
	new key = str_to_num(info)
	
	switch(key)
	{
		case 1:
		{
			Create_Table(id)
		}
		case 2:
		{
			new iEnt, body, szClassname[32]
			get_user_aiming(id, iEnt, body)
			
			if (is_valid_ent(iEnt)) 
			{
				entity_get_string(iEnt, EV_SZ_classname, szClassname, charsmax(szClassname));
				
				if (equal(szClassname,CLASS_NAME_TABLE)) 
				{
					remove_entity(iEnt)
				}
				
			}
		}
		case 3:
		{
			Save_Table()
			
			ColorChat(id,"%s Originile Weapon Table's au fost salvate cu succes!",Tag)
		}
		case 4:
		{
			remove_entity_name(CLASS_NAME_TABLE)
			
			ColorChat(id,"%s Toate Weapon Table's au fost sterse!",Tag)
		}
	}
	menu_display(id, menu)
	
	return PLUGIN_HANDLED
}

public Touch_Table(ent,toucher)
{
	if(!pev_valid(toucher))
	return HAM_HANDLED
	
	if(!is_user_alive(toucher))
	 return HAM_HANDLED
	
	if(l4d_is_user_zombie(toucher))
	      return HAM_HANDLED
	
	if(get_user_button(toucher) & IN_USE && get_user_oldbutton(toucher) & IN_USE)
	{
		if(AntiSpam2[toucher])
		  return HAM_HANDLED
		    
		AntiSpam2[toucher] = true
		
		drop_weapons(toucher,1)
		
		give_item(toucher,random_weapons[random_num(0,sizeof(random_weapons) - 1)])
		AntiSpam[toucher] = true
		
		pipe_bomb(toucher)
		
		new weapon = get_user_weapon(toucher)
		
		switch(weapon)
		{
			case CSW_AK47:
			{
				cs_set_user_bpammo(toucher,CSW_AK47,200)
			}
			case CSW_M4A1:
			{
				cs_set_user_bpammo(toucher,CSW_M4A1,200)
			}
			case CSW_AUG:
			{
				cs_set_user_bpammo(toucher,CSW_AUG,200)
			}
			case CSW_AWP:
			{
				cs_set_user_bpammo(toucher,CSW_AWP,200)
			}
			case CSW_FAMAS:
			{
				cs_set_user_bpammo(toucher,CSW_FAMAS,200)
			}
			case CSW_GALIL:
			{
				cs_set_user_bpammo(toucher,CSW_GALIL,200)
			}
			case CSW_G3SG1:
			{
				cs_set_user_bpammo(toucher,CSW_G3SG1,200)
			}
			case CSW_M3:
			{
				cs_set_user_bpammo(toucher,CSW_M3,50)
			}
			case CSW_MAC10:
			{
				cs_set_user_bpammo(toucher,CSW_MAC10,100)
			}
			case CSW_MP5NAVY:
			{
				cs_set_user_bpammo(toucher,CSW_MP5NAVY,150)
			}
			case CSW_XM1014:
			{
				cs_set_user_bpammo(toucher,CSW_XM1014,50)
			}
		}
	}
	set_task(1.5,"Re_use",toucher)
	
	
	return HAM_SUPERCEDE
}

public Re_use(id)
{
	remove_task(id)
	
	if(l4d_is_user_zombie(id) || !is_user_alive(id))
			return
			
	AntiSpam2[id] = false
}

Create_Table(id, Float:flOrigin[3]= { 0.0, 0.0, 0.0 }, Float:flAngle[3]= { 0.0, 0.0, 0.0 } )
{
	//Create an entity using type 'info_target'
	new ent = create_entity("info_target")
	
	//Set our entity to have a classname so we can filter it out late
	
	if(id)
	{
		//Retrieve the player's origin
		entity_get_vector(id, EV_VEC_origin, flOrigin)
		//Set the origin of the NPC to the current players location
		flOrigin[2] -= 25.0
		entity_set_origin(ent, flOrigin);
		//Increase the Z-Axis by 80 and set our player to that location so they won't be stuck
		flOrigin[2] += 80.0;
		entity_set_origin(id, flOrigin);
		
		//Retrieve the player's  angle
		entity_get_vector(id, EV_VEC_angles, flAngle)
		//Make sure the pitch is zeroed out
		flAngle[0] = 0.0
		//Set our NPC angle based on the player's angle
		entity_set_vector(ent, EV_VEC_angles, flAngle)
	}
	//If we are reading from a file
	else 
	{
		//Set the origin and angle based on the values of the parameters
		entity_set_origin(ent, flOrigin)
		entity_set_vector(ent, EV_VEC_angles, flAngle)
	}
	
	entity_set_string(ent, EV_SZ_classname,CLASS_NAME_TABLE)
	
	entity_set_int(ent, EV_INT_solid,SOLID_TRIGGER)
	
	entity_set_float(ent, EV_FL_health,7000.0)
	
	entity_set_model(ent,table_model)
	
	entity_set_float(ent, EV_FL_animtime, get_gametime())
	entity_set_float(ent, EV_FL_framerate, 1.0)
	entity_set_float(ent, EV_FL_gravity, 1.0)
	
	return 1
}

Save_Table()
{
	//Variables
	new szConfigsDir[256], szFile[256], szNpcDir[256];
	
	//Get the configs directory.
	get_configsdir(szConfigsDir, charsmax(szConfigsDir));
	
	//Get the current map name
	new szMapName[32];
	get_mapname(szMapName, charsmax(szMapName));
	
	//Format 'szNpcDir' to ../configs/NPC
	formatex(szNpcDir, charsmax(szNpcDir),"%s/Weapon_Table", szConfigsDir);
	//Format 'szFile to ../configs/NPC/mapname.cfg
	formatex(szFile, charsmax(szFile), "%s/%s.cfg", szNpcDir, szMapName);
		
	//If there is already a .cfg for the current map. Delete it
	if(file_exists(szFile))
		delete_file(szFile);
	
	//Variables
	new iEnt = -1, Float:fEntOrigin[3], Float:fEntAngles[3];
	new sBuffer[256];
	
	//Scan and find all of my custom ents
	while( ( iEnt = find_ent_by_class(iEnt, CLASS_NAME_TABLE) ) )
	{
		//Get the entities' origin and angle
		entity_get_vector(iEnt, EV_VEC_origin, fEntOrigin);
		entity_get_vector(iEnt, EV_VEC_angles, fEntAngles);
		
		//Format the line of one custom ent.
		formatex(sBuffer, charsmax(sBuffer), "%d %d %d | %d", floatround(fEntOrigin[0]), floatround(fEntOrigin[1]), floatround(fEntOrigin[2]), floatround(fEntAngles[1]));
		
		//Finally write to the mapname.cfg file and move on to the next line
		write_file(szFile, sBuffer, -1);
		
		//We are currentlying looping to find all custom ents on the map. If found another ent. Do the above till there is none.
	}
}

Load_Table()
{
	//Get the correct filepath and mapname
	new szConfigDir[256], szFile[256], szNpcDir[256];
	
	get_configsdir(szConfigDir, charsmax(szConfigDir));
	
	new szMapName[32];
	get_mapname(szMapName, charsmax(szMapName));
	
	formatex(szNpcDir, charsmax(szNpcDir),"%s/Weapon_Table", szConfigDir);
	formatex(szFile, charsmax(szFile),  "%s/%s.cfg", szNpcDir, szMapName);
		
	//If the filepath does not exist then we will make one
	if(!dir_exists(szNpcDir))
	{
		mkdir(szNpcDir);
	}
	
	//If the map config file does not exist we will make one
	if(!file_exists(szFile))
	{
		write_file(szFile, "");
	}
	
	//Variables to store when reading our file
	new szFileOrigin[3][32]
	new sOrigin[128], sAngle[128];
	new Float:fOrigin[3], Float:fAngles[3];
	new iLine, iLength, sBuffer[256];
	
	//When we are reading our file...
	while(read_file(szFile, iLine++, sBuffer, charsmax(sBuffer), iLength))
	{
		//Move to next line if the line is commented
		if((sBuffer[0]== ';') || !iLength)
			continue;
		
		//Split our line so we have origin and angle. The split is the vertical bar character
		strtok(sBuffer, sOrigin, charsmax(sOrigin), sAngle, charsmax(sAngle), '|', 0);
				
		//Store the X, Y and Z axis to our variables made earlier
		parse(sOrigin, szFileOrigin[0], charsmax(szFileOrigin[]), szFileOrigin[1], charsmax(szFileOrigin[]), szFileOrigin[2], charsmax(szFileOrigin[]));
		
		fOrigin[0] = str_to_float(szFileOrigin[0]);
		fOrigin[1] = str_to_float(szFileOrigin[1]);
		fOrigin[2] = str_to_float(szFileOrigin[2]);
				
		//Store the yawn angle
		fAngles[1] = str_to_float(sAngle[1]);
		
		//Create our NPC
		Create_Table(0, fOrigin, fAngles)
		
		//Keep reading the file until the end
	}
}

stock ColorChat( const id, const input[ ], any:... )
{
new count = 1, players[ 32 ]

static msg[ 191 ]
vformat( msg, 190, input, 3 )

replace_all( msg, 190, "!v", "^4" ) //- verde
replace_all( msg, 190, "!g", "^1" ) //- galben
replace_all( msg, 190, "!e", "^3" ) //- echipa
replace_all( msg, 190, "!n", "^0" ) //- normal

if( id ) players[ 0 ] = id; else get_players( players, count, "ch" )
{
for( new i = 0; i < count; i++ )
{
if( is_user_connected( players[ i ] ) )
{
message_begin( MSG_ONE_UNRELIABLE, get_user_msgid( "SayText" ), _, players[ i ] )
write_byte( players[ i ] );
write_string( msg );
message_end( );
}
}
}
}

stock drop_weapons(id, dropwhat)
{
	// Get user weapons
	static weapons[32], num, i, weaponid
	num = 0 // reset passed weapons count (bugfix)
	get_user_weapons(id, weapons, num)
	
	// Weapon bitsums
	const PRIMARY_WEAPONS_BIT_SUM = (1<<CSW_SCOUT)|(1<<CSW_XM1014)|(1<<CSW_MAC10)|(1<<CSW_AUG)|(1<<CSW_UMP45)|(1<<CSW_SG550)|(1<<CSW_GALIL)|(1<<CSW_FAMAS)|(1<<CSW_AWP)|(1<<CSW_MP5NAVY)|(1<<CSW_M249)|(1<<CSW_M3)|(1<<CSW_M4A1)|(1<<CSW_TMP)|(1<<CSW_G3SG1)|(1<<CSW_SG552)|(1<<CSW_AK47)|(1<<CSW_P90)
	const SECONDARY_WEAPONS_BIT_SUM = (1<<CSW_P228)|(1<<CSW_ELITE)|(1<<CSW_FIVESEVEN)|(1<<CSW_USP)|(1<<CSW_GLOCK18)|(1<<CSW_DEAGLE)	
	
	// Loop through them and drop primaries or secondaries
	for (i = 0; i < num; i++)
	{
		// Prevent re-indexing the array
		weaponid = weapons[i]
		
		if ((dropwhat == 1 && ((1<<weaponid) & PRIMARY_WEAPONS_BIT_SUM)) || (dropwhat == 2 && ((1<<weaponid) & SECONDARY_WEAPONS_BIT_SUM)))
		{
			// Get weapon entity
			static wname[32], weapon_ent
			get_weaponname(weaponid, wname, charsmax(wname))
			weapon_ent = fm_find_ent_by_owner(-1, wname, id)
			
			// Hack: store weapon bpammo on PEV_ADDITIONAL_AMMO
			set_pev(weapon_ent, pev_iuser1, cs_get_user_bpammo(id, weaponid))
			
			// Player drops the weapon and looses his bpammo
			engclient_cmd(id, "drop", wname)
			cs_set_user_bpammo(id, weaponid, 0)
		}
	}
}

stock pipe_bomb(id)
{
	if(user_has_weapon(id,CSW_SMOKEGRENADE))
		    return FMRES_IGNORED
	
		pipe_give_to_user(id)
		
	return FMRES_SUPERCEDE
}
	
	
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1033\\ f0\\ fs16 \n\\ par }
*/
